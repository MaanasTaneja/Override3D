// Real Time Renderer.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include "CRenderable.h"
#include "CRenderer.h"
#include "FlyCamera.h"
#include "globals.h"

#include "DEBUGHelperFunctions.h"

#include "RenderableList.h"
#include "Scene.h"

#include <Windows.h>


void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void mouse_callback(GLFWwindow* window, double xpos, double ypos);
void processInput(GLFWwindow* window);

//CRENDERER AND SPEW are part of valve's source engine, I CANNOT HAVE EVEN THE SLIGHTEST BIT OF shade that i saw that code, attempted to analyse it or anything, so keep 
//think about this, i want to keep my CA etc abbreviations tho, remove spew and other MORE OBVIOUS inspirations 

void testupdatefcn(Override::CRenderable* obj)
{
    obj->setrotation(glm::vec3(0.0f, (float)glfwGetTime() * 10, 0.0f));
}


void morefcn(Override::CRenderable* obj)
{
    obj->setrotation(glm::vec3(0.0f, (float)glfwGetTime() * 100, 0.0f));
}


void anotherscene(Override::CRenderable* obj)
{
    obj->setrotation(glm::vec3((float)glfwGetTime() * 10, (float)glfwGetTime() * 10, (float)glfwGetTime() * 10));
}


bool bro = false;

Override::FlyCamera scenecam{ glm::vec3(-4.59293f , 6.61621f ,  1.95588f) };  //initial position is at origin

int main()
{
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    GLFWwindow* window = glfwCreateWindow(Globals::SCR_WIDTH, Globals::SCR_HEIGHT, "Real Time Renderer", NULL, NULL);
    if (window == NULL)
    {
        std::cout << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    glfwSetCursorPosCallback(window, mouse_callback);

    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);


    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return -1;
    }


    //Screwed after I enabled back face culling because these verts (cube and traingle) dont have any normals specified 
    float cubevertices[] = {
     -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
      0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
      0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
      0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
     -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

     -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
      0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
      0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
      0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
     -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
     -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

     -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

      0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
      0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
      0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
      0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
      0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
      0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

     -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
      0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
      0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
      0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

     -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
      0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
      0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
      0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
     -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
    };          
    float triangle[] = {
        0.0f, 1.0f, 0.0f, 0.5f, 0.5f,
        -1.0f, -1.0f, 0.0f,0.0f, 0.0f,
        1.0f, -1.0f, 0.0f,1.0f, 0.0f
    };

    scenecam.SetPerspective(glm::radians(45.0f), (float)Globals::SCR_WIDTH / (float)Globals::SCR_HEIGHT, 0.1f, 100.0f);

    Override::Scene currentScene{ &scenecam };

    Override::Scene anotherScene{ &scenecam };


    std::vector<Override::Vertex> texturedtriangle = DebugHelperToolkit::pack2vertices_nonormal(triangle, sizeof(triangle) / (sizeof(float) * 5));
    std::vector<Override::Vertex> out = DebugHelperToolkit::pack2vertices_nonormal(cubevertices, sizeof(cubevertices) / (sizeof(float) * 5));


    Override::CMesh mesh{ out };
    Override::CMesh mesh2{ texturedtriangle };

    Override::Shader shader{ "..\\Resources\\shaders\\testVert.txt", "..\\Resources\\shaders\\testFrag.txt" };

    Override::CMaterial material{ Globals::MATSPEC_PHONG, &shader };
    material.textureload_phong("..\\Resources\\textures\\wood_lowres.jpg", "..\\Resources\\textures\\wood_lowres.jpg");
    material.m_phong.diffuse.setfiltering(GL_NEAREST);
    material.m_phong.diffuse.wrapping(GL_REPEAT);
    material.m_phong.diffuse.mipmap();     //Implemented nearest filering mipmapping 
    material.m_phong.diffuse.rebuild(Globals::TEXTURE_2D, "..\\Resources\\textures\\wood_lowres.jpg");

    Override::CMaterial material2{ Globals::MATSPEC_PHONG, &shader };
    material2.textureload_phong("..\\Resources\\textures\\fabric_lowres.jpg", "..\\Resources\\textures\\wood_lowres.jpg");

    material2.m_phong.diffuse.setfiltering(GL_NEAREST);
    material2.m_phong.diffuse.wrapping(GL_REPEAT);
    material2.m_phong.diffuse.mipmap();     //Implemented nearest filering mipmapping 
    material2.m_phong.diffuse.rebuild(Globals::TEXTURE_2D, "..\\Resources\\textures\\fabric_lowres.jpg");


    Override::CRenderable renderable{ &mesh, &material, Globals::RENDERABLE_COMMON };
    renderable.setrotation(glm::vec3(0.0f, 20.0f, 0.0f));
    renderable.setcustomupdate(&testupdatefcn);

    Override::CRenderable renderable2{ &mesh2, &material2, Globals::RENDERABLE_COMMON };

    renderable2.setposition(glm::vec3(0.0f, 0.5f, 0.0f));
    renderable2.setcustomupdate(&morefcn);

    Override::CRenderable renderable3{ &mesh, &material2, Globals::RENDERABLE_COMMON };
    renderable3.setcustomupdate(&anotherscene);


    Override::Transform windmillTrans{ 0.25f };
    windmillTrans.m_position = glm::vec3(-0.0f, 5.0f, -0.2f);


    Override::RenderableList windmill{};
    windmill = Override::Model{ "..\\Resources\\models\\windmill\\windmill2.obj", Globals::MATSPEC_PHONG, &shader, windmillTrans};
    currentScene.addSceneNode(windmill);

    Override::Transform knightTrans{ 0.5f };
    knightTrans.m_position = glm::vec3(-1.3f, 5.0f, 0.0f);
    knightTrans.m_rotation - glm::vec3(10.0f, 90.0f, 0.0f);

    Override::RenderableList knight{};
    knight = Override::Model{ "..\\Resources\\models\\knight\\knight.obj", Globals::MATSPEC_PHONG, &shader, knightTrans };
    currentScene.addSceneNode(knight);

    Override::RenderableList sunset{};
    sunset = Override::Model("..\\Resources\\models\\sunset\\sunset.obj", Globals::MATSPEC_PHONG, &shader);
    for (auto i : sunset.m_list)
    {
        i->m_type = Globals::RENDERABLE_BACKGROUND_STATIC; 
    }
    currentScene.addSceneNode(sunset);

    Override::Transform platTrans{ 0.25f };

    Override::RenderableList plat{};
    plat = Override::Model("..\\Resources\\models\\Plateau\\Plateau.obj", Globals::MATSPEC_PHONG, &shader, platTrans);
    currentScene.addSceneNode(plat);


    Override::Transform n64_chestTrans{ 0.01f };
    n64_chestTrans.m_position = glm::vec3(-0.0f, 5.0f, -1.0f);
    Override::RenderableList n64_chest{};
    n64_chest = Override::Model("..\\Resources\\models\\N64_Zelda\\chest\\Big Treasure Chest.obj", Globals::MATSPEC_PHONG, &shader, n64_chestTrans);
    currentScene.addSceneNode(n64_chest);


    Override::RenderableList primitives{};
    Override::Transform primitivesWorld{ 0.5f };
    primitivesWorld.m_position = glm::vec3(-3.0f, 5.5f, 0.0f);
    primitivesWorld.m_rotation = glm::vec3(90.0f, 0.0f, 0.0f);

    primitives.setRootTransform(primitivesWorld);
    primitives.push(&renderable);
    primitives.push(&renderable2);
    currentScene.addSceneNode(primitives);

    
    Override::Transform n64_treeworldTrans{ 0.01f };
    n64_treeworldTrans.m_position = glm::vec3(-0.0f, 5.0f, -1.0f);
    Override::RenderableList n64_tree_world{};
    n64_tree_world = Override::Model("..\\Resources\\models\\N64_Zelda\\forest\\Kokiri Forest.obj", Globals::MATSPEC_PHONG, &shader, n64_treeworldTrans);
    anotherScene.addSceneNode(n64_tree_world);

    Override::Transform hl_snarkpitTrans{ 0.05f };
    hl_snarkpitTrans.m_position = glm::vec3(-0.0f, 5.0f, -1.0f);
    Override::RenderableList hl_snarkpit{};
    hl_snarkpit = Override::Model("..\\Resources\\models\\PC\\HL\\snarkpit\\Snark_Pit.obj", Globals::MATSPEC_PHONG, &shader, hl_snarkpitTrans);
    //anotherScene.addSceneNode(hl_snarkpit);

    Override::Transform tes_centTrans{ 5.0f };
    tes_centTrans.m_position = glm::vec3(0.0f, 0.0f, 0.0f);
    Override::RenderableList tes_cent{};
    tes_cent = Override::Model("..\\Resources\\models\\PC\\TES\\centurian\\Centurion Archer.obj", Globals::MATSPEC_PHONG, &shader, tes_centTrans);
    //anotherScene.addSceneNode(tes_cent);


    Override::Transform cs16_dustTrans{ 0.05f };
    cs16_dustTrans.m_position = glm::vec3(-0.0f, 5.0f, -1.0f);
    Override::RenderableList cs16_dust{};
    cs16_dust = Override::Model("..\\Resources\\models\\PC\\QUAKE\\intro\\start.obj", Globals::MATSPEC_PHONG, &shader, cs16_dustTrans);
    //anotherScene.addSceneNode(cs16_dust);




 

    while (!glfwWindowShouldClose(window))
    {
        float currentFrame = glfwGetTime();
        Globals::deltaTime = currentFrame - Globals::lastFrame;
        Globals::lastFrame = currentFrame;
        processInput(window);

        if (bro == true)
        {
            anotherScene.beginframe();
            anotherScene.updatescene(Globals::deltaTime);
            anotherScene.renderscene();

            anotherScene.endframe();
        }

        else
        {

            currentScene.beginframe();
            currentScene.updatescene(Globals::deltaTime);
            currentScene.renderscene();

            currentScene.endframe();
        }

       
        glfwSwapBuffers(window);
        glfwPollEvents();
    }


    glfwTerminate();
}

void processInput(GLFWwindow* window)
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);

    if (glfwGetKey(window, GLFW_KEY_G) == GLFW_PRESS)
        bro = true;

    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
        scenecam.InputKey(Globals::deltaTime, Override::CAMERA_FORWARD);
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        scenecam.InputKey(Globals::deltaTime, Override::CAMERA_BACK);
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        scenecam.InputKey(Globals::deltaTime, Override::CAMERA_LEFT);
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        scenecam.InputKey(Globals::deltaTime, Override::CAMERA_RIGHT);
}


void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{

    glViewport(0, 0, width, height);
}

void mouse_callback(GLFWwindow* window, double xposIn, double yposIn)
{
    scenecam.InputMouse(xposIn, yposIn);
}